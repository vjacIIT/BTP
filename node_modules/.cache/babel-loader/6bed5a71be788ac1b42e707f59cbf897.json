{"ast":null,"code":"export function swap(array, indexA, indexB) {\n  let temp = array[indexA];\n  array[indexA] = array[indexB];\n  array[indexB] = temp;\n  return array;\n}\nexport function insertStep(arrayNew, position, arraySteps) {\n  let currentStep = arraySteps[arraySteps.length - 1].slice();\n  currentStep.splice(position, arrayNew.length, ...arrayNew);\n  arraySteps.push(currentStep);\n} // Backtracks from the finishNode to find the shortest path\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/home/vjac/Work/BTP/dijkstra/src/algorithms/helpers.js"],"names":["swap","array","indexA","indexB","temp","insertStep","arrayNew","position","arraySteps","currentStep","length","slice","splice","push","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","previousNode"],"mappings":"AACA,OAAO,SAASA,IAAT,CAAcC,KAAd,EAAqBC,MAArB,EAA6BC,MAA7B,EAAqC;AAC1C,MAAIC,IAAI,GAAGH,KAAK,CAACC,MAAD,CAAhB;AACAD,EAAAA,KAAK,CAACC,MAAD,CAAL,GAAgBD,KAAK,CAACE,MAAD,CAArB;AACAF,EAAAA,KAAK,CAACE,MAAD,CAAL,GAAgBC,IAAhB;AACA,SAAOH,KAAP;AACD;AAED,OAAO,SAASI,UAAT,CAAoBC,QAApB,EAA8BC,QAA9B,EAAwCC,UAAxC,EAAoD;AACzD,MAAIC,WAAW,GAAGD,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAAV,CAAkCC,KAAlC,EAAlB;AACAF,EAAAA,WAAW,CAACG,MAAZ,CAAmBL,QAAnB,EAA6BD,QAAQ,CAACI,MAAtC,EAA8C,GAAGJ,QAAjD;AACAE,EAAAA,UAAU,CAACK,IAAX,CAAgBJ,WAAhB;AACD,C,CAED;;AACA,OAAO,SAASK,2BAAT,CAAqCC,UAArC,EAAgD;AACrD,QAAMC,wBAAwB,GAAG,EAAjC;AACA,MAAIC,WAAW,GAAGF,UAAlB;;AACA,SAAME,WAAW,KAAK,IAAtB,EAA2B;AACxBD,IAAAA,wBAAwB,CAACE,OAAzB,CAAiCD,WAAjC;AACAA,IAAAA,WAAW,GAAGA,WAAW,CAACE,YAA1B;AACF;;AACD,SAAOH,wBAAP;AACD","sourcesContent":["\nexport function swap(array, indexA, indexB) {\n  let temp = array[indexA];\n  array[indexA] = array[indexB];\n  array[indexB] = temp;\n  return array;\n}\n\nexport function insertStep(arrayNew, position, arraySteps) {\n  let currentStep = arraySteps[arraySteps.length - 1].slice();\n  currentStep.splice(position, arrayNew.length, ...arrayNew);\n  arraySteps.push(currentStep);\n}\n\n// Backtracks from the finishNode to find the shortest path\nexport function getNodesInShortestPathOrder(finishNode){\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while(currentNode !== null){\n     nodesInShortestPathOrder.unshift(currentNode);\n     currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}"]},"metadata":{},"sourceType":"module"}