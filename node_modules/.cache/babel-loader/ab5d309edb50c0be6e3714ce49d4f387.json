{"ast":null,"code":"/* \n   Dijkstra Algorithm\n*/\nimport { getNodesInShortestPathOrder } from './helpers';\n\nconst dijkstra = (grid, startNode, finishNode, gridSteps) => {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodeByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); //If we encounter a wall we skip it\n\n    if (closestNode.isWall) continue; //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    const {\n      col,\n      row\n    } = closestNode;\n    grid[row][col].isVisited = true;\n    gridSteps.push(grid);\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n\n  return;\n};\n\nfunction sortNodeByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const neighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of neighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport default dijkstra;","map":{"version":3,"sources":["/home/vjac/Work/BTP/dijkstra/src/algorithms/dijkstra.js"],"names":["getNodesInShortestPathOrder","dijkstra","grid","startNode","finishNode","gridSteps","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodeByDistance","closestNode","shift","isWall","Infinity","isVisited","col","row","push","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","neighbours","getUnvisitedNeighbours","neighbour","previousNode","filter","nodes"],"mappings":"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","sourcesContent":["/* \n   Dijkstra Algorithm\n*/\nimport {getNodesInShortestPathOrder} from './helpers';\n\nconst dijkstra = (grid, startNode, finishNode, gridSteps) => {\n  const visitedNodesInOrder = [];\n  startNode.distance=0;\n  const unvisitedNodes = getAllNodes(grid);\n  while(!!unvisitedNodes.length){\n     sortNodeByDistance(unvisitedNodes);\n     const closestNode = unvisitedNodes.shift();\n     //If we encounter a wall we skip it\n     if (closestNode.isWall) continue;\n\n     //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n     if(closestNode.distance === Infinity) return visitedNodesInOrder;\n\n     closestNode.isVisited=true;\n     const {col, row} = closestNode;\n     grid[row][col].isVisited=true;\n     gridSteps.push(grid);\n     visitedNodesInOrder.push(closestNode);\n     if(closestNode === finishNode){\n        return visitedNodesInOrder;\n     }\n     updateUnvisitedNeighbours(closestNode, grid);\n  }\n  return;\n}\n\nfunction sortNodeByDistance(unvisitedNodes){\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid){\n  const neighbours = getUnvisitedNeighbours(node, grid);\n  for(const neighbour of neighbours){\n     neighbour.distance = node.distance + 1;\n     neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid){\n  const neighbours = [];\n  const {col, row} = node;\n  if(row > 0) neighbours.push(grid[row-1][col]);\n  if(row < grid.length -1) neighbours.push(grid[row+1][col]);\n  if(col > 0) neighbours.push(grid[row][col-1])\n  if(col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid){\n  const nodes = [];\n  for(const row of grid){\n     for(const node of row){\n        nodes.push(node);\n     }\n  }\n  return nodes;\n}\n\nexport default dijkstra;"]},"metadata":{},"sourceType":"module"}