{"ast":null,"code":"/* \n   Breadth First Search (BFS) Algorithm\n*/\n//import {getNodesInShortestPathOrder} from './helpers';\nconst bfs = (grid, startNode, finishNode, trace) => {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodeByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); //If we encounter a wall we skip it\n\n    if (closestNode.isWall) continue; //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n\n  return;\n};\n\nfunction sortNodeByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const neighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of neighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport default bfs;","map":{"version":3,"sources":["/home/vjac/Work/BTP/dijkstra/src/algorithms/bfs.js"],"names":["bfs","grid","startNode","finishNode","trace","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodeByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","neighbours","getUnvisitedNeighbours","neighbour","previousNode","col","row","filter","nodes"],"mappings":"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","sourcesContent":["/* \n   Breadth First Search (BFS) Algorithm\n*/\n//import {getNodesInShortestPathOrder} from './helpers';\n\nconst bfs = (grid, startNode, finishNode, trace) => {\n  const visitedNodesInOrder = [];\n  startNode.distance=0;\n  const unvisitedNodes = getAllNodes(grid);\n  while(!!unvisitedNodes.length){\n     sortNodeByDistance(unvisitedNodes);\n     const closestNode = unvisitedNodes.shift();\n     //If we encounter a wall we skip it\n     if (closestNode.isWall) continue;\n     \n     //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n     if(closestNode.distance === Infinity) return visitedNodesInOrder;\n\n     closestNode.isVisited=true;\n     visitedNodesInOrder.push(closestNode);\n     if(closestNode === finishNode){\n        return visitedNodesInOrder;\n     }\n     updateUnvisitedNeighbours(closestNode, grid);\n  }\n  return;\n}\n\nfunction sortNodeByDistance(unvisitedNodes){\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid){\n  const neighbours = getUnvisitedNeighbours(node, grid);\n  for(const neighbour of neighbours){\n     neighbour.distance = node.distance + 1;\n     neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid){\n  const neighbours = [];\n  const {col, row} = node;\n  if(row > 0) neighbours.push(grid[row-1][col]);\n  if(row < grid.length -1) neighbours.push(grid[row+1][col]);\n  if(col > 0) neighbours.push(grid[row][col-1])\n  if(col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid){\n  const nodes = [];\n  for(const row of grid){\n     for(const node of row){\n        nodes.push(node);\n     }\n  }\n  return nodes;\n}\n\nexport default bfs;"]},"metadata":{},"sourceType":"module"}