{"ast":null,"code":"/* \n   Dijkstra Algorithm\n*/\nimport { getNodesInShortestPathOrder } from './helpers';\n\nconst dijkstra = (grid, startNode, finishNode, gridSteps) => {\n  //let colorKey = colorSteps[colorSteps.length - 1].slice();\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodeByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); //If we encounter a wall we skip it\n\n    if (closestNode.isWall) continue; //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    gridSteps.push(grid.slice());\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) {\n      return; //return visitedNodesInOrder;\n    }\n\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n\n  return;\n};\n\nfunction sortNodeByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const neighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of neighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport default dijkstra;","map":{"version":3,"sources":["/home/vjac/Work/BTP/dijkstra/src/algorithms/dijkstra.js"],"names":["getNodesInShortestPathOrder","dijkstra","grid","startNode","finishNode","gridSteps","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodeByDistance","closestNode","shift","isWall","Infinity","isVisited","push","slice","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","neighbours","getUnvisitedNeighbours","neighbour","previousNode","col","row","filter","nodes"],"mappings":"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","sourcesContent":["/* \n   Dijkstra Algorithm\n*/\nimport {getNodesInShortestPathOrder} from './helpers';\n\nconst dijkstra = (grid, startNode, finishNode, gridSteps) => {\n   //let colorKey = colorSteps[colorSteps.length - 1].slice();\n   const visitedNodesInOrder = [];\n   startNode.distance=0;\n   const unvisitedNodes = getAllNodes(grid);\n   while(!!unvisitedNodes.length){\n     sortNodeByDistance(unvisitedNodes);\n     const closestNode = unvisitedNodes.shift();\n     //If we encounter a wall we skip it\n     if (closestNode.isWall) continue;\n\n     //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n     if(closestNode.distance === Infinity) return visitedNodesInOrder;\n\n     closestNode.isVisited=true;\n     gridSteps.push(grid.slice());\n     visitedNodesInOrder.push(closestNode);\n     if(closestNode === finishNode){\n         return;\n         //return visitedNodesInOrder;\n     }\n     updateUnvisitedNeighbours(closestNode, grid);\n  }\n  return;\n}\n\nfunction sortNodeByDistance(unvisitedNodes){\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid){\n  const neighbours = getUnvisitedNeighbours(node, grid);\n  for(const neighbour of neighbours){\n     neighbour.distance = node.distance + 1;\n     neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid){\n  const neighbours = [];\n  const {col, row} = node;\n  if(row > 0) neighbours.push(grid[row-1][col]);\n  if(row < grid.length -1) neighbours.push(grid[row+1][col]);\n  if(col > 0) neighbours.push(grid[row][col-1])\n  if(col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid){\n  const nodes = [];\n  for(const row of grid){\n     for(const node of row){\n        nodes.push(node);\n     }\n  }\n  return nodes;\n}\n\nexport default dijkstra;"]},"metadata":{},"sourceType":"module"}