{"ast":null,"code":"/* \n   Dijkstra Algorithm\n*/\nimport { getNodesInShortestPathOrder } from './helpers';\n\nconst dijkstra = (grid, startNode, finishNode, gridSteps, colorSteps) => {\n  let colorKey = colorSteps[colorSteps.length - 1].slice();\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodeByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); //If we encounter a wall we skip it\n\n    if (closestNode.isWall) continue; //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    gridSteps.push(grid);\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n\n  return;\n};\n\nfunction sortNodeByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const neighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of neighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport default dijkstra;","map":{"version":3,"sources":["/home/vjac/Work/BTP/dijkstra/src/algorithms/dijkstra.js"],"names":["getNodesInShortestPathOrder","dijkstra","grid","startNode","finishNode","gridSteps","colorSteps","colorKey","length","slice","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","sortNodeByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","sort","nodeA","nodeB","node","neighbours","getUnvisitedNeighbours","neighbour","previousNode","col","row","filter","nodes"],"mappings":"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","sourcesContent":["/* \n   Dijkstra Algorithm\n*/\nimport {getNodesInShortestPathOrder} from './helpers';\n\nconst dijkstra = (grid, startNode, finishNode, gridSteps, colorSteps) => {\n   let colorKey = colorSteps[colorSteps.length - 1].slice();\n   const visitedNodesInOrder = [];\n   startNode.distance=0;\nconst unvisitedNodes = getAllNodes(grid);\n   while(!!unvisitedNodes.length){\n     sortNodeByDistance(unvisitedNodes);\n     const closestNode = unvisitedNodes.shift();\n     //If we encounter a wall we skip it\n     if (closestNode.isWall) continue;\n\n     //If the closest node is at a distance of infinity we must be trapped and should therefore stop\n     if(closestNode.distance === Infinity) return visitedNodesInOrder;\n\n     closestNode.isVisited=true;\n     gridSteps.push(grid);\n     visitedNodesInOrder.push(closestNode);\n     if(closestNode === finishNode){\n        return visitedNodesInOrder;\n     }\n     updateUnvisitedNeighbours(closestNode, grid);\n  }\n  return;\n}\n\nfunction sortNodeByDistance(unvisitedNodes){\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbours(node, grid){\n  const neighbours = getUnvisitedNeighbours(node, grid);\n  for(const neighbour of neighbours){\n     neighbour.distance = node.distance + 1;\n     neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid){\n  const neighbours = [];\n  const {col, row} = node;\n  if(row > 0) neighbours.push(grid[row-1][col]);\n  if(row < grid.length -1) neighbours.push(grid[row+1][col]);\n  if(col > 0) neighbours.push(grid[row][col-1])\n  if(col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getAllNodes(grid){\n  const nodes = [];\n  for(const row of grid){\n     for(const node of row){\n        nodes.push(node);\n     }\n  }\n  return nodes;\n}\n\nexport default dijkstra;"]},"metadata":{},"sourceType":"module"}