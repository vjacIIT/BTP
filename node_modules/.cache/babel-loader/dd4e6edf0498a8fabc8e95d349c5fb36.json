{"ast":null,"code":"import { insertStep } from './helpers';\n\nfunction mergeSort(array, position, arraySteps, colorSteps) {\n  if (array.length === 1) return array;\n  let mid = Math.floor(array.length / 2); // Split and work recursively\n\n  let arrayA = mergeSort(array.slice(0, mid), position, arraySteps, colorSteps);\n  let arrayB = mergeSort(array.slice(mid), position + mid, arraySteps, colorSteps);\n  let arrayNew = merge(arrayA, arrayB, position, arraySteps, colorSteps);\n  arraySteps.push(arraySteps[arraySteps.length - 1].slice());\n  colorSteps.push(colorSteps[colorSteps.length - 1].fill(arrayNew.length === arraySteps[0].length ? 2 : 0));\n  return arrayNew;\n}\n\nconst merge = (arrayA, arrayB, position, arraySteps, colorSteps) => {\n  let arrayNew = [];\n  let A = 0;\n  let B = 0;\n\n  while (arrayA.length > 0 && arrayB.length > 0) {\n    if (arrayA[A] < arrayB[B]) {\n      arrayNew.push(arrayA.shift());\n      insertStep(arrayNew, position, arraySteps);\n    } else {\n      arrayNew.push(arrayB.shift());\n      insertStep(arrayNew, position, arraySteps);\n    }\n\n    updateColor(position, colorSteps, arrayNew.length - 1, [], []);\n  } // concatenate remaining values\n\n\n  if (arrayA.length !== 0 || arrayB.length !== 0) {\n    updateColor(position, colorSteps, arrayNew.length, arrayA, arrayB);\n    arrayNew = arrayNew.concat(arrayA);\n    arrayNew = arrayNew.concat(arrayB);\n    insertStep(arrayNew, position, arraySteps);\n  }\n\n  return arrayNew;\n};\n\nfunction updateColor(position, colorSteps, start, arrayA, arrayB) {\n  let colorKey = colorSteps[colorSteps.length - 1].slice();\n  let end = position + start + arrayA.length + arrayB.length;\n  start = start + position;\n\n  if (end === start) {\n    colorKey.fill(1, start, end + 1);\n  } else {\n    colorKey.fill(1, start, end);\n  }\n\n  colorSteps.push(colorKey);\n}\n\nexport default mergeSort;","map":{"version":3,"sources":["/home/vjac/Work/BTP/dijkstra/src/algorithms/mergeSort.js"],"names":["insertStep","mergeSort","array","position","arraySteps","colorSteps","length","mid","Math","floor","arrayA","slice","arrayB","arrayNew","merge","push","fill","A","B","shift","updateColor","concat","start","colorKey","end"],"mappings":"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","sourcesContent":["import { insertStep } from './helpers';\n\nfunction mergeSort(array, position, arraySteps, colorSteps) {\n  if (array.length === 1) return array;\n  let mid = Math.floor(array.length / 2);\n\n  // Split and work recursively\n  let arrayA = mergeSort(array.slice(0, mid), position, arraySteps, colorSteps);\n  let arrayB = mergeSort(array.slice(mid), position + mid, arraySteps, colorSteps);\n\n  let arrayNew = merge(arrayA, arrayB, position, arraySteps, colorSteps);\n  arraySteps.push(arraySteps[arraySteps.length - 1].slice());\n  colorSteps.push(colorSteps[colorSteps.length - 1].fill(arrayNew.length === arraySteps[0].length ? 2 : 0));\n  return arrayNew;\n}\n\nconst merge = (arrayA, arrayB, position, arraySteps, colorSteps) => {\n  let arrayNew = [];\n  let A = 0;\n  let B = 0;\n\n  while (arrayA.length > 0 && arrayB.length > 0) {\n    if (arrayA[A] < arrayB[B]) {\n      arrayNew.push(arrayA.shift());\n      insertStep(arrayNew, position, arraySteps);\n    } else {\n      arrayNew.push(arrayB.shift());\n      insertStep(arrayNew, position, arraySteps);\n    }\n    updateColor(position, colorSteps, arrayNew.length - 1, [], []);\n  }\n\n  // concatenate remaining values\n\n  if (arrayA.length !== 0 || arrayB.length !== 0) {\n    updateColor(position, colorSteps, arrayNew.length, arrayA, arrayB);\n    arrayNew = arrayNew.concat(arrayA);\n    arrayNew = arrayNew.concat(arrayB)\n    insertStep(arrayNew, position, arraySteps);\n  }\n\n  return arrayNew;\n}\n\nfunction updateColor(position, colorSteps, start, arrayA, arrayB) {\n  let colorKey = colorSteps[colorSteps.length - 1].slice();\n  let end = position + start + arrayA.length + arrayB.length;\n  start = start + position;\n\n  if (end === start) {\n    colorKey.fill(1, start, end + 1);\n  } else {\n    colorKey.fill(1, start, end);\n  }\n  colorSteps.push(colorKey);\n}\n\nexport default mergeSort;"]},"metadata":{},"sourceType":"module"}